\chapter{Реляционная алгебра и её применения}

%ralg: label prefix
На практике часто сталкиваются с необходимостью долговременного хранения больших объемов данных. Обычно такая необходимость возникает в системах, регистрирующих определенные события, например: факты продаж в магазите, результаты сессии в университете, платежи в интернет-магазине, регистрация пользователей на сайтах и т.д. Регистрируемое событие можно описать кортежем количественных и качественных значений. Множество, состоящее из событий-кортежей, как уже известно, представляет собой отношение. Реляционная алгебра определяет операции над отношениями и является теоретической основой реляционных баз данных. Формальное определение реляционной алгебры можно найти в \cite{bib:gorbatovs:discrmath,bib:haggard:discrmathprogrammer}. Тем же, кто заинтересуется практическими вопросами организации, хранения и обработки данных можно рекомендовать специализированные книги по базам данных, например, \cite{bib:krenke:db}. Краткая теория приведена ниже.


\section{Реляционная алгебра}

Два отношения $P_1$ и $P_2$, имеющие одинаковую \emph{арность}, называются \emph{совместимыми}. При этом, если 
\[P\subseteq A_1\times A_2\times\ldots\times A_n,\]
то $A_i$ называется $i$-м \emph{доменом} отношения $P$. В \emph{реляционной алгебре} вводятся следующие операции над отношениями.

\begin{enumerate}
    \item Для совместимых отношений $P_1$ и $P_2$ применимы операции алгебры множеств:
    \begin{enumerate}
        \item Объединение: $P_1\cup P_2$;
        \item Пересечение: $P_1\cap P_2$;
        \item Разность: $P_1\backslash P_2$.
    \end{enumerate}
    
    \item \emph{Расширенным декартовым произведением} двух отношений (любой арности) $P_1$ и $P_2$ называется отношение, состоящее из конкатенаций соответствующих кортежей из $P_1$ и $P_2$:
    \[
        \begin{split}
            P_1\times P_2=\{(a_1,a_2,\ldots,a_n,b_1,b_2,\ldots,b_m)|\\
            (a_1,a_2,\ldots,a_n)\in P_1,(b_1,b_2,\ldots,b_m)\in P_2\}.
        \end{split}
    \]
    
    \item $\text{Выб}(P,C)$. Операция \emph{выбора} $\text{Выб}(P,C)$ получает из отношения $P$ подмножество кортежей, удовлетворяющих условию $C$:
    \[
        \text{Выб}(P,C)=\{(a_1,a_2,\ldots,a_n)|(a_1,a_2,\ldots,a_n)\in P,C(a_1,a_2,\ldots,a_n)\}.
    \]
    
    \item Операция \emph{проекции}. Если $P\subseteq A_1\times A_2\times\ldots\times A_n$ и задано отображение 
    \[f:\{1,2,\ldots,m\}\to\{1,2,\ldots,n\},\] 
    то результат операции проекции определяется так:
    \[
        \begin{split}
            \text{Пр}(P/(A_{f(1)},A_{f(2)},\ldots,A_{f(m)}))=\\
            \{(a_{f(1)},a_{f(2)},\ldots,a_{f(m)})|(a_1,a_2,\ldots,a_n)\in P\}.
        \end{split}
    \]
    
    \item $\text{Соед}(P_1,P_2,A_i=B_j)$. Операция \emph{соединения} отношений $P_1$ и $P_2$ по общему домену $D=A_i\cap B_j$.
    \[
        \begin{split}
            P_1\subseteq A_1\times A_2\times\ldots\times A_i\times\ldots\times A_m,\\
            P_2\subseteq B_1\times B_2\times\ldots\times B_j\times\ldots\times B_n.
        \end{split}
    \]
    Тогда
    \[
        \begin{split}
            \text{Соед}(P_1,P_2,A_i=B_j)=\text{Пр}(\text{Выб}(P_1\times P_2, A_i=B_j)/\\
            A_1,A_2,\ldots,A_m,B_1,B_2,\ldots B_{j-1},B_{j+1},\ldots,B_n).
        \end{split}
    \]
    
    То есть каждый кортеж результата получаются конкатенацией кортежей исходных отношений, у которых значения общего домена совпадают, и координата общего домена входит в результат только один раз. Операция легко расширяется до соединения по нескольким общим доменам.
    
    \item $\text{Соед}(P_1,P_2,C)$. Общий случай соединения. Операция \emph{соединения по условию $C$} двух отношений $P_1$ и $P_2$:
    \[
        \begin{split}
            \text{Соед}(P_1,P_2,C)=\text{Выб}(P_1\times P_2,C).
        \end{split}
    \]
\end{enumerate}


\begin{exampl}
    Пусть $P_1\subseteq A_1\times A_2, P_2\subseteq B_1\times B_2\times B_3$:
    \[
        \begin{split}
            P_1=\{(a,1),(a,2),(b,3),(c,4)\},\\
            P_2=\{(a,\lambda,2),(b,\beta,3)\}.
        \end{split}
    \]
    Тогда, например, 
    \begin{itemize}
        \item Расширенное декартово произведение:
        \[
            \begin{split}
                P_1\times P_2=\{
                    (a,1,a,\lambda,2),(a,1,b,\beta,3),\\
                    (a,2,a,\lambda,2),(a,2,b,\beta,3),\\
                    (b,3,a,\lambda,2),(b,3,b,\beta,3),\\ 
                    (c,4,a,\lambda,2),(c,4,b,\beta,3)
                \}.
            \end{split}
        \]
        
        \item Выбор:
        \[
            \begin{split}
                \text{Выб}(P_1,A_1=a)=\{(a,1),(a,2)\},\\
                \text{Выб}(P_1,A_2>2)=\{(b,3),(c,4)\},\\
                \text{Выб}(P_1,A_1=A_2)=\emptyset
            \end{split}
        \]
        
        \item Проекция:
        \[
            \begin{split}
                \text{Пр}(P_1/A_1)=\{a,b,c\},\\
                \text{Пр}(P_2/(B_1,B_3))=\{(a,2),(b,3)\}, \\            
                \text{Пр}(P_2/(B_3,B_2,B_1))=\{(2,\lambda,a),(3,\beta,b)\}, \\
            \end{split}
        \]
        
        \item Соединение:
        \[
            \begin{split}
                \text{Соед}(P_1,P_2,A_1=B_1)=\{
                    (a,1,\lambda,2),
                    (a,2,\lambda,2),
                    (b,3,\beta,3)                     
                \}\\
                \text{Соед}(P_1,P_2,(A_1=B_1\land A_2=B_3))=\{
                    (a,2,\lambda),
                    (b,3,\beta)                     
                \}\\
                \text{Соед}(P_1,P_2,(A_2>2\land B_3>2))=\{
                    (b,3,b,\beta,3),(c,4,b,\beta,3)
                \}\\
            \end{split}
        \]        
    \end{itemize}
    И, конечно, операции можно свободно комбинировать: $\text{Выб}(\text{Соед}(P_1,P_2,A_1=B_1), A_2<B_3)=\{(a,1,\lambda,2)\}$.
    \qed
\end{exampl}


\section{Реляционные базы данных. Основы SQL}

Задача сбора, хранения и обработки данных настолько распространена, что со временем появились специальные программные системы, решающие эти задачи --- СУБД. СУБД --- система управления базой данных. Прикладные программы, которым требуется работа с большими объемами данных, общаются с СУБД через программный интерфейс, позволяющий им задавать структуру базы данных, сохранять, удалять и выбирать необходимые данные, не заботясь о том, как именно решаются эти сложные подзадачи. 

Системы управления реляционными базами данных получили широкое распространение. Прилагательное \emph{реляционная} (relation --- отношение) означает то, что данные представлены отношениями. Отношению в реляционной базе данных соответствует таблица с соответствующим именем, а доменам отношения --- имена столбцов (см. например, рис. \ref{tbl:ralg:Student}). Собственно реляционная база данных --- это также именованная сущность, состоящая (упрощенно) из нескольких таблиц.

Как прикладная программа взаимодействует с реляционной СУБД? Посредством текстовых запросов на специализированном языке SQL. SQL --- Structured Query Language (язык структурированных запросов\footnote{SQL --- язык четвертого поколения: представитель узко специализированных языков высокого уровня}). Прикладная программа посылает базе данных запрос\footnote{Запрос может быть послан, например, по сети, если СУБД и прикладная программа исполняются на разных компьютерах}, содержащий предложение SQL и получает ответ. Типы предложений на SQL могут быть разные: 
\begin{itemize}
    \item создать(удалить) базу данных с некоторым уникальным именем;
    \item создать(удалить,модифицировать) таблицу с уникальным именем в пределах конкретной базы данных;
    \item записать(удалить,модифицировать) данные в таблицу базы данных;
    \item выбрать данные из одной или нескольких таблиц;
    \item создать/удалить пользователя базы данных;
    \item и т.д.
\end{itemize}

Разные будут и ответы на запросы. Далее будует рассмотрена лишь малая часть языка SQL, касающаяся выборки данных. Эта часть языка полностью реализует операции реляционной алгебры, и в качестве ответа на запрос, прикладной программе передается таблица\footnote{Более того, возможности SQL по выборке данных выходят за пределы реляционной алгебры, например некоторые столбцы результирующей таблицы могут быть \emph{вычислены}}. Необходимо отметить, что разноименные таблицы могут иметь столбцы с одинаковыми именами, при этом к столбцу $x$ таблицы $T$ можно обратиться $T.x$.

Существует стандарт на язык SQL, а это значит, что с различными СУБД\footnote{Конечно, поддерживающими стандарт!}, прикладная программа может <<разговаривать>> на одном языке.

Проведем аналогии между основными операциями реляционной алгебры и SQL. Все возможности реляционной алгебры заключаются в одном операторе SQL, который имеет следующую структуру\footnote{Структура запроса сильно упрощена}:
\begin{verbatim}
select <имена столбцов таблиц проекции>
from   <имена таблиц-источников>
where  <условие выбора>
\end{verbatim}

Дадим перевод ключевых слов: \verb"select" --- <<выбрать>>; \verb"from" --- <<из>>; \verb"where" --- <<где>>. Итак, после ключевого слова \verb"from" через запятую перечисляются имена таблиц-источников (т.е. отношений $T_1,T_2,\ldots,T_n$), после ключевого слова \verb"where" следует условие \emph{выбора}, накладываемое на кортежи отношения \[P=T_1\times T_2\times\ldots\times T_n,\] а после ключевого слова \verb"select" указываются имена столбцов таблиц, которые войдут в \emph{проекцию} отфильтнованного по условию отношения $P$.

В качестве примера некоторой базы данных приводятся таблицы \ref{tbl:ralg:Student}-\ref{tbl:ralg:StudentSection}. Дальнейшие примеры SQL-запросов приводятся на их основе.

\begin{itemize}
    \item Выбор на SQL:
\begin{verbatim}
select * from Студент where Студент.пол='Ж';
\end{verbatim}    
        
    Будут выбраны записи о девушках. Символ звездочки \verb"*" означает <<выбрать все столбцы>>. Если указать не звездочку, а имена столбцов, то это будет соответствовать проекции.
    \item Проекция на SQL:
\begin{verbatim}    
select Студент.фамилия from Студент;
\end{verbatim}    

    Будут выбраны все фамилии студентов.
    \item Соединение на SQL:
\begin{verbatim}    
select 
    Студент.номер, Студент.имя, Студент.фамилия, 
    СекцияСтудента.НомерСекции 
from 
    Студент,СекцияСтудента 
where Студент.Номер=СекцияСтудента.НомерСтудента;
\end{verbatim}    
    Будет создана таблица содержащая номер, имя и фамилию студента, а также номер секции, в которую он записан. Ничто не мешает выполнить соединение сразу трех таблиц (выведем лишь названия секций, в которые записан студент):
\begin{verbatim}    
select 
    Студент.номер, Студент.имя, Студент.фамилия, 
    Студент.фамилия, Секция.Название
from 
    Студент,СекцияСтудента,Секция
where 
    Студент.Номер=СекцияСтудента.НомерСтудента and
    СекцияСтудента.НомерСекции=Секция.номер;
\end{verbatim}
\end{itemize}

\begin{table}
    \centering
    \begin{tabular}{|l|l|l|l|l|l|}
        \hline\hline
        Номер & Фамилия         & Имя           & Отчество      & ДеньРожд   & Пол\\
        \hline\hline
        2001  & Иванов          & Иван          & Иванович      & 28.02.1991 & М\\
        2002  & Александрова    & Александра    & Александровна & 07.05.1992 & Ж\\
        2003  & Петров          & Петр          & Петрович      & 23.12.1982 & М\\
        2004  & Евгеньева       & Евгения       & Евгеньевна    & 13.11.1981 & Ж\\
        2005  & Сидоров         & Сидор         & Сидорович     & 30.07.1989 & М\\
        2006  & Валентинова     & Валентина     & Валентиновна  & 17.01.1992 & Ж\\
        2007  & Ильин           & Илья          & Ильич         & 03.10.1985 & М\\
        \hline
    \end{tabular}
    \caption{Таблица <<Студент>>}
    \label{tbl:ralg:Student}
\end{table}    

\begin{table}
    \centering
    \begin{tabular}{|l|l|l|l|l|}
        \hline\hline
        Номер & Фамилия         & Имя           & Отчество      &  Пол\\
        \hline\hline
        301   & Иванов          & Джеб          & Оперкотович   &  М\\
        302   & Пончик          & Сет           & Либерович     &  М\\
        303   & Девяткина       & Александра    & Эйсовна       &  Ж\\
        \hline
    \end{tabular}
    \caption{Таблица <<Тренер>>}
    \label{tbl:ralg:Trainer}
\end{table}    

\begin{table}
    \centering
    \begin{tabular}{|l|l|l|}
        \hline\hline
        Номер   & Название  & Плата\\
        \hline\hline
        1       & Теннис    & 2000\\
        2       & Футбол    & 1000\\
        3       & Волейбол  & 800\\
        4       & Сумо      & 1500\\
        5       & Бокс      & 600\\
        \hline
    \end{tabular}
    \caption{Таблица <<Секция>>}
    \label{tbl:ralg:Section}
\end{table}    

\begin{table}
    \centering
    \begin{tabular}{|l|l|}
        \hline\hline
        НомерТренера    & НомерСекции \\
        \hline\hline
        301             & 5\\
        302             & 4\\
        302             & 3\\
        303             & 1\\
        303             & 2\\
        \hline
    \end{tabular}
    \caption{Таблица <<ТренерСекции>>}
    \label{tbl:ralg:SectionTrainer}
\end{table}

\begin{table}
    \centering
    \begin{tabular}{|l|l|}
        \hline\hline
        НомерСекции     & НомерСтудента \\
        \hline\hline
        1               & 2001\\
        1               & 2007\\
        2               & 2002\\
        3               & 2006\\
        4               & 2004\\
        4               & 2003\\
        5               & 2001\\
        \hline
    \end{tabular}
    \caption{Таблица <<СекцияСтудента>>}
    \label{tbl:ralg:StudentSection}
\end{table}    

Ответ на вопрос: <<почему база данных имеет именно такую структуру?>> --- можно найти в любой книге о базах данных.


\section*{Задания}
\addcontentsline{toc}{section}{Задания}

\begin{enumerate}
    \item Даны два совместимых отношения $P_1=A_1\times A_2\times A_3$ и $P_2=B_1\times B_2\times B_3$:
    \[
        \begin{split}
            P_1=\{
                (1,a,\alpha),
                (2,a,\alpha),
                (3,b,\beta),
                (4,c,\beta)
            \},\\
            P_2=\{
                (1,a,\alpha),
                (2,b,\beta),
                (3,c,1)
            \}.
        \end{split}
    \]

    Найти:
    \begin{enumerate}
        \item $P_1\cap P_2$;
        \item $P_1\cup P_2$;
        \item $P_1\backslash P_2$;
        \item $\text{Выб}(P_1,A_3=\beta)$;
        \item $\text{Пр}(P_1/(A_2,A_3))$;
        \item $\text{Соед}(P_2,P_2,A_1=A_3)$;
        \item $\text{Соед}(P_1,P_2,(A_2=B_2\land A_3=B_3))$;
        \item $\text{Пр}(\text{Соед}(P_1,P_2,A_1<B_1)/(A_1,B_1,A_3))$;
    \end{enumerate}
    
    \item Необходимо составить и выполнить SQL-запрос к базе данных (см. таблицы \ref{tbl:ralg:Student}-\ref{tbl:ralg:StudentSection}), дающий ответ на вопрос:
    \begin{enumerate}
        \item Кто из студентов-девушек старше 25 на момент 01.01.2011\footnote{Даже к базе данных такой запрос нужно писать крайне осторожно!}?
        \item В каких секциях плата составляет больше 900?
        \item Каковы фамилии однофамильцев среди тренеров и студентов?
        \item В какие секции ходит студент Иванов?
        \item Кто является тренером для каждой секции?
        \item Кто тренирует Ильина?
        \item Какие студенты ходят в секцию Тенниса?
        \item Какие студенты ходят в секцию плата за которую превышает 900?
        \item У кого из студентов его тренер по секции является тёзкой или однофамильцем?
    \end{enumerate}
    
    \item Составление более сложных SQL запросов требуют дополнительных знаний\footnote{Без чтения дополнительной литературы не обойтись}:
    \begin{enumerate}
        \item Кто из студентов не ходит ни в одну секцию?
        \item Сколько платят студенты за посещение секций?
        \item Кто из студентов платит за посещение секций больше всех?
        \item Кто из тренеров получает за занятия со студентами больше остальных?
        \item Каковы фамилии мужчин, посещающих и проводящих секции Тенниса и Бокса?
    \end{enumerate}
\end{enumerate}
