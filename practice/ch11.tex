\chapter{Анализ алгоритмов}
\label{ch:alg}

Согласно \cite{bib:knuth:artOfProgramming1} \emph{алгоритмом} называют набор конечного числа правил, задающих последовательность выполнения операций для решения задачи определённого типа, имеющий пять особенностей.
\begin{enumerate}
    \item \emph{Конечность}. Алгоритм всегда должен заканчиваться после конечного числа шагов. \emph{Метод вычислений}, в отличие от алгоритма, не обладает свойством конечности.
    
    \item \emph{Определенность}. Каждый шаг алгоритма должен быть четко определен. Языки программирования, например, четко определяют значение (смысл) каждого предложения. Метод вычислений, выраженный на языке программирования, называется \emph{программой}.
    
    \item \emph{Ввод}. Алгоритм имеет определенное (иногда нулевое) число входных данных.
    
    \item \emph{Вывод}. Алгоритм имеет определенное число выходных данных.
    
    \item \emph{Эффективность}. Алгоритм эффективен, когда все его шаги достаточно просты для того, чтобы их можно было точно выполнить в течение конечного промежутка времени.
\end{enumerate}

Анализу подвергаются следующие характеристики:
\begin{itemize}
    \item время выполнения алгоритма;
    \item объем памяти, необходимый для выполнения алгоритма.
\end{itemize}

Следует заметить: то, что названо <<временем выполнения алгоритма>> вовсе не измеряется в секундах. Оценка в секундах будет характеризовать скорее конкретный компьютер, исполняющий алгоритм, а не сам алгоритм. Поэтому термин <<время>> в данном контексте следует понимаеть скорее как <<число шагов>>\footnote{А число шагов, очевидно, отразится и на времени исполнения каким бы то ни было компьютером}. Впрочем, и точное количество шагов при анализе не представляет большого интереса. Достаточно приближенно оценить зависимость количества шагов (операций) от размера входных данных.

Далее внимание уделяется именно анализу <<времени>> выполнения алгоритма, а не затрат памяти. Впрочем, подход остается тем же. 

Подробнее об анализе алгоритмов см. \cite{bib:haggard:discrmathprogrammer}. Книги \cite{bib:miller:secParAlghorithm, bib:mcconnel:alghorithmAnalysis} целиком посвящены теме анализа алгоритмов.


\section{Скорости роста}

Одну и ту же задачу можно решить разными алгоритмами. Более того, один и тот же алгоритм можно выразить разными программами на различных языках программирования. Одна и та же программа может быть выполнена отличающимися по производительности компьютерами.

С практической точки зрения важно сделать обоснованный выбор лучшего из алгоритмов, решающих одну и ту же задачу, основываясь на изучении самого алгоритма, а не выражая алгоритм в программе (и тем более не проводя тестовых запусков на компьютере). Это основная задача анализа. 

При этом точные значения характеристик (время, память) не столь важны. Важнее дать приближенную оценку \emph{скорости} их роста с увеличением размера входных данных $n$. То есть интерес представляет общий характер поведения алгоритма, а не его подробности.

Допустим, что для алгоритма $A$ можно вывести функцию $g:\mathbb{N}\to[0,\infty)$, которая по заданному размеру данных $n$ вычисляет время выполнения алгоритма (или затраты памяти). При этом данную функцию можно отнести к следующим трем классам скорости роста функций:
\begin{enumerate}
    \item Класс функций, растущих по крайней мере так же быстро как $f(n)$. Обозначается этот класс как $\Omega(f(n))$ (читается как \emph{омега большое}). Функция $g(n)$ принадлежит этому классу(обозначается $g\in\Omega(f)$), если при всех значениях аргумента $n$, больших некоторого порогового значения $n_0$, значение $g(n)>c\cdot f(n)$ для некоторого положительного числа $c$.
    
    \item Класс функций, растущих не быстрее $f(n)$. Обозначается этот класс как $O(f(n))$ (читается как \emph{о большое}). Функция $g(n)$ принадлежит этому классу (обозначается $g\in O(f)$), если при всех значениях аргумента $n$, больших некоторого порогового значения $n_0$, значение $g(n)\leq c\cdot f(n)$ для некоторого положительного числа $c$.
    
    \item Класс функций, растущих той же скоростью, что и $f(n)$. Обозначается этот класс как $\Theta(f(n))$ (читается как \emph{тета большое}). Формально $\Theta(f(n))=\Omega(f(n))\cap O(f(n))$.
\end{enumerate}

Таким образом при анализе алгоритмов не столь важно \emph{точно} вывести функцию $g$, сколь определить какому классу скорости роста она принадлежит. Из перечисленных классов для анализа наиболее важен класс $O(f)$. Проверить, принадлежит ли функция классу $O(f)$ можно двумя способами: с помощью данного выше определения класса $O(f)$, либо воспользовавшись следующим описанием:
\[
    g\in O(f),\text{если} \lim_{n\to\infty}\frac{g(n)}{f(n)}=c
\]
для некоторой константы $c$. Иными словами, если удается найти предел отношения $g(n)/f(n)$ и он меньше бесконечности, то $g\in O(f)$. Если предел найти сложно, то по правилу Лопиталя можно заменить предел отношения функций пределом отношения их производных.

$O(f)$ является классом эквивалентности $f$ и для некоторой функции $g$ правильно писать $g\in O(f)$, но иногда по соглашению пишут $g=O(f)$, что на самом деле означает именно $g\in O(f)$.

Скорость роста некоторых функций $f$ проиллюстрирована в таблице \ref{alg:tbl:gorwth}. Так, например, если обработка на компьютере массива входных данных размером $n=1$ алгоритмом с $g(n)=n^2$ составляет $10^{-9}$ секунд(наносекунду), то обработка массива из $100$ элементов займет $10^{-3}$ секунд. Но если для обработки массива используется алгоритм $g(n)=2^n$, и массив из одного элемента обрабатывается за $10^{-9}$ с., то $100$ элементный массив будет обработан приблизительно за $20000$ миллиардов лет.
\begin{table}
    \centering
    \begin{tabular}{||r||r|r|r|r|r|r|}
        \hline\hline
        $n$ & $\log_2n$ & $n$ & $n\log_2n$ & $n^2$ & $n^3$ & $2^n$\\ \hline\hline
          1 & 0.00 &   1 &    0.00 &     1 &       1 &                                 2\\
          2 & 1.00 &   2 &    2.00 &     4 &       8 &                                 4\\
          4 & 2.00 &   4 &    8.00 &    16 &      64 &                                16\\
          5 & 2.32 &   5 &   11.61 &    25 &     125 &                                32\\
         10 & 3.32 &  10 &   33.22 &   100 &    1000 &                              1024\\
         20 & 4.32 &  20 &   86.44 &   400 &    8000 &                           1048576\\
         40 & 5.32 &  40 &  212.88 &  1600 &   64000 &                     1099511627776\\
         60 & 5.91 &  60 &  354.41 &  3600 &  216000 &               1152921504606846976\\
         80 & 6.32 &  80 &  505.75 &  6400 &  512000 &         1208925819614629174706176\\
        100 & 6.64 & 100 &  664.39 & 10000 & 1000000 &   1267650600228229401496703205376\\
        \hline
    \end{tabular} 
    \caption{Скорость роста функций}
    \label{alg:tbl:gorwth}
\end{table}

Важными классами роста являются классы, образуемые \emph{полиномиальными} функциями 
\begin{equation}
    P(n)=a_k\cdot n^k + a_{k-1}\cdot n^{k-1} + \cdots + a_1\cdot n + a_0,
    \label{eq:alg:polinom}
\end{equation}
где $a_k\neq 0$. Считается, например, что если у алгоритма полиномиальное время работы, то удастся создать компьютер, выполняющий алгоритм за приемлемое время для больших $n$, а если время работы алгоритма растет быстрее чем любой полином\footnote{Например, $g(n)\in O(2^n)$}, то надежды на это нет\footnote{Это может изменится с приходом эры квантовых компьютеров}.

Быстрорастущие функции доминируют над функциями с более медленным ростом. Поэтому, если $g(n)$ представляет собой сумму двух или нескольких таких функций, то часто отбрасываются все функции, кроме тех, которые растут быстрее всего. Также, если функция $g(n)=c\cdot f(n)$, то можно отбросить $c$: $g\in O(f)$. Например для полиномов (см. формулу \eqref{eq:alg:polinom}) справедливо $P(n)\in O(n^k)$.

Некоторые функции $f$, упорядоченные по возрастанию скорости:$f(n)=1$, $f(n)=\log_2n$, $f(n)=n$, $f(n)=n\log_2n$, $f(n)=n^2$, $f(n)=n^2\log_2n$, $f(n)=n^3$, \ldots, $f(n)=n^k$, \ldots, $f(n)=2^n$, $f(n)=n!$, $f(n)=n^n$, \ldots.

\begin{exampl} 
    \label{exampl:alg:strongest}
    Функция $g(n)=5n^3+2\log_2n$ принадлежит классу $O(n^3)$.\qed
\end{exampl}

Далее будут рассмотрены несколько методик оценки сложности, которые позволяют вывести $g(n)$ для алгоритма.


\section{Классы входных данных}

Зафиксировав размер входных даннных $n$, можно тем не менее видеть, что в большинстве случаев время выполнения алгоритма для различных наборов данных одного размера также будет различным. Действительно, алгоритмы редко бывают линейными, чаще они содержат операции \emph{выбора}, выполняющие различные действия в зависимости от условий, меняющихся в ходе выполнения.

\begin{exampl}
    Необходимо найти индекс первого элемента в неотсортированном массиве длины $n$, равного искомому.
\end{exampl}
\begin{proof}
    В лучшем случае искомый элемент будет в самом начале массива (первым) и потребуется только одна операция сравнения. Лучший случай имеет сложность $O(1)$. В худшем случае искомого значения в массиве не будет, и придется выполнить $n$ сравнений. Сложность худшего случая $O(n)$. В случае, если значение искомого элемента находится в $i$-й ячейке массива, то потребуется $i$ сравнений. Оценить, сколько операций сравнения будет в среднем, можно, приняв некоторые допущения (которые иногда могут оказаться не вполне справедливыми):
    \begin{enumerate}
        \item искомый элемент может оказаться в любом месте массива с равной вероятностью $p_i=\frac{1}{n}$;
        \item искомого элемента может не оказаться в массиве в половине случаев.
    \end{enumerate}

    Тогда, среднее количество операций сравнений может быть найдено как
    \[
        g(n)=\frac{1}{2}n+\frac{1}{2}\sum_{i=1}^{n}p_i\cdot i=\frac{1}{2}\left(n+\frac{1}{n}\frac{n(n+1)}{2}\right)=
        \frac{3}{4}n+\frac{1}{4}.
    \]

    Сложность среднего случая $g\in O(n)$.
\end{proof}

Оценку лучшего случая проводят редко --- он не представляет большого интереса. Оценка наихудшего случая дает верхнюю оценку времени работы. Обычно дают оценку именно худщего случая. Оценить средний случай сложнее всего, но именно эта оценка наиболее адекватна. Общий подход оценки среднего случая заключается в следующем. Все возможные варианты входных наборов данных длины $n$ разбивается на группы. Время работы алгоритма на всех входных наборах группы должно быть одинаковым. Определяется вероятность с которой некоторый входной набор принадлежит каждой группе. Среднее время работы вычисляется по формуле
\[
    g(n)=\sum_{i=1}^{m}p_i\cdot t_i,
\]
где $n$ --- размер входных данных, $m$ --- число групп, $p_i$ --- вероятность принадлежности входного набора $i$-й группе, $t_i$ --- время работы алгоритма для $i$-й группы. Иногда предполагают равную вероятность попадания в любую группу и тогда 
\[
    g(n)=\frac{1}{m}\sum_{i=1}^{m}t_i.
\]

В рассмотренном примере при оценке среднего случая все множество входных наборов данных было разбито на два подмножества: содержащие искомый элемент и не содержащие. Множество наборов, содержащих искомый элемент, было разбито на $n$ групп: в $i$-й группе искомый элемент находится в $i$-й ячейке.


\section{Анализ программ}

Одна и та же задача может быть решена различными алгоритмами, выраженными в различных программах. Например, задача поиска максимального элемента среди трех может быть решена, например, псевдокодом \ref{alg:alg:maxOfThree1} или \ref{alg:alg:maxOfThree2}. Первый вариант содержит меньше условных конструкций, испльзует больше памяти и его проще понять. Тем не менее в ходе выполнения приведенных программ выполняется по два сравнения и с этой точки зрения у них одинаковый уровень сложности. Алгоритмы решения некоторых задач принадлежат разным классам скоростей роста времени выполнения.

\begin{algorithm}
    \caption{Поиск наибольшенго элемента среди $a,b,c$}
    \label{alg:alg:maxOfThree1}
    \begin{algorithmic}[1]
        \REQUIRE{$a,b,c$ --- три значения, среди которых ищется наибольший}
        \ENSURE{наибольший элемент}

        \STATE{$m\gets a$} 
        \IF{$b>m$}
            \STATE{$m\gets b$}
        \ENDIF
        \IF{$c>m$}
            \STATE{$m\gets c$}
        \ENDIF
        \RETURN{$m$}
    \end{algorithmic}
\end{algorithm}
\begin{algorithm}
    \caption{Поиск наибольшенго элемента среди $a,b,c$}
    \label{alg:alg:maxOfThree2}
    \begin{algorithmic}[1]
        \REQUIRE{$a,b,c$ --- три значения, среди которых ищется наибольший}
        \ENSURE{наибольший элемент}

        \IF{$a>b$}
            \IF{$c>a$}
                \RETURN{$c$}
            \ELSE
                \RETURN{$a$}
            \ENDIF
        \ELSE[$b\geq a$]
            \IF{$c>b$}
                \RETURN{$c$}
            \ELSE
                \RETURN{$b$}
            \ENDIF            
        \ENDIF
    \end{algorithmic}
\end{algorithm}

Так или иначе, но алгоритм должен быть <<выражен>>. В программе, в блок схеме, в словесном описании\ldots Далее приводится ряд примеров анализа программ, в которых выражены алгоритмы. Будует использован псевдокод, в котором представлены основные элементы структурного программирования: \emph{последовательность}, \emph{выбор}, \emph{повторение}.

Оценка последовательности наиболее проста (см. псевдокод \ref{alg:alg:sequention}). 
\begin{algorithm}
    \caption{$A(n)$ --- последовательность в структурном программировании}
    \label{alg:alg:sequention}
    \begin{algorithmic}[1]
        \REQUIRE{$S_1,S_2,\ldots,S_k$ --- последовательно выполняющиеся операторы. Для каждого из них известна оценка их времени выполнения: $g_{S_1}(n), g_{S_2}(n),\ldots,g_{S_k}(n)$}
        
        \STATE{$S_1$} 
        \STATE{$S_2$} 
        \STATE{$\ldots$} 
        \STATE{$S_k$} 
    \end{algorithmic}
\end{algorithm}
Очевидно, что оценка алгоритма --- это сумма оценок каждого оператора последовательности:
\[
g_A(n)=\sum_{i=1}^{k} g_{S_i}(n).
\]

Выбор в структурном программировании представлен условным оператором (см. псеводокод \ref{alg:alg:select}).
\begin{algorithm}
    \caption{$A(n)$ --- выбор в структурном программировании}
    \label{alg:alg:select}
    \begin{algorithmic}[1]
        \REQUIRE{$S_1,S_2$ --- операторы с известной оценкой времени выполнения: $g_{S_1}(n), g_{S_2}(n)$. Оценка условия $C$ --- $g_{C}(n)$}
        
        \IF{$C$}
            \RETURN{$S_1$}
        \ELSE
            \RETURN{$S_2$}
        \ENDIF
    \end{algorithmic}
\end{algorithm}
Для оценки лучшего случая выбора, очевидно:
\[g_A(n)=g_C(n)+\min\{g_{S_1}(n), g_{S_2}(n)\}.\]
Худшего случая:
\[g_A(n)=g_C(n)+\max\{g_{S_1}(n), g_{S_2}(n)\}.\]
Среднего случая:
\[g_A(n)=g_C(n) + p_{S_1}\cdot g_{S_1}(n) + p_{S_2}\cdot g_{S_2}(n),\]
где $p_{S_i}$ --- вероятность выбора оператора $S_i$.

После того, как в получившихся формулах будут отброшены медленно растущие слагаемые (см. пример \ref{exampl:alg:strongest}), то оценки для худшего и среднего случая будут совпадать.

Повторение в структурном программировании представлено конструкцией цикла (см. псевдокод \ref{alg:alg:loop}). Анализ цикла прост, когда это цикл с заданным числом повторений. В противном случае оценка количества итераций цикла не столь тривиальна.
\begin{algorithm}
    \caption{$A(n)$ --- повторение в структурном программировании}
    \label{alg:alg:loop}
    \begin{algorithmic}[1]
        \REQUIRE{$S$ --- оператор цикла с известной оценкой времени выполнения $g_S(i)$.}
        
        \FOR{$i=1$ to $n$}
            \STATE{$S$}\COMMENT{время выполнения зависит от $i$}
        \ENDFOR
    \end{algorithmic}
\end{algorithm}
Число ключевых операций цикла в данном случае находится как
\[
    g_A(n)=c+\sum_{i=1}^{n}(c+g_S(i)),
\]
где $c$ --- количество ключевых операций, затрачиваемых на проверку условия окончания цикла (часто $c=0$).

При анализе часто возникают суммы, которые можно свести к замкнутой форме. Далее приводятся наиболее полезные из них. В числе простейших:
\begin{gather}
    \sum_{i=1}^{n}1=n\\
    \sum_{i=1}^{n}c=cn\\
    \sum_{i=1}^{n}i=\frac{n(n+1)}{2}.
\end{gather}
Более сложные суммы:
\begin{gather}
    \sum_{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}\\
    \sum_{i=0}^{n}A^i=\frac{A^{n+1}-1}{A-1}\label{eq:alg:sumsApowi}\\
    \sum_{i=1}^{n}i2^i=(n-1)2^{n+1}+2\\
\end{gather}
Следует обратить внимание на то, что в формуле \eqref{eq:alg:sumsApowi} нижняя граница индекса равна нулю. Важным частным случаем этой формулы является 
\[
    \sum_{i=0}^{n}2^i=2^{n+1}-1.
\] 
Часто используется и биномиальная теорема:
\begin{equation}
    \label{eq:alg:binomTheorem}
    \sum_{i=0}^{n}\binom{n}{i}A^{i}B^{n-i} = (A+B)^{n},
\end{equation}
где $\binom{n}{i}=\frac{n!}{i!(n-i)!}$.
Наконец, несколько приближенных формул:
\begin{gather}
    \sum_{i=1}^{n}\frac{1}{i}\approx \ln n\\
    \sum_{i=1}^{n}\log_2i\approx n\log_2n-1.5
\end{gather}


\section{$P$ и $NP$}

Задачи, оценка сложности которых по времени выполнения не превышает $O(n^k)$ называются \emph{полиномиальными} (см. полином ф-ла \eqref{eq:alg:polinom}). \emph{Точное} решение подобных задач может быть найдено за <<разумный>> промежуток времени. Все подобные задачи относятся к классу $P$ --- классу задач \emph{полиномиальной сложности}. Также такие задачи назваются \emph{практически разрешимыми}.

Для задачи, образующих класс $NP$ --- класс \emph{недетерминированной полиномиальной сложности}, до сих пор не известно детерминированных алгоритмов, способных решать их за <<разумное>> время (т.е. полиномиальных). Детерминированным называется алгоритм, вывод которого полностью определяется его вводом. Иначе, алгоритм называется недетерминированным (например, вывод такого алгоритма зависит не только от ввода, но и от обращений к генератору случайных чисел). Задачи класса $NP$ называются также <<практически наразрешимыми>>. Детерминированные алгоритмы решения таких задач хоть и существуют, но они имеют сложность превышающую $O(2^n)$ (большинство имеют экспоненциальную или факториальную сложность). 

Так как решать $NP$ задачу детерминированным алгоритмом (т.е. алгоритмом сложнее $O(2^n)$) бессмысленно, то на практике, чтобы получить удовлетворительное решение, выполняют некоторое подобие попытки его угадать. Иногда такая попытка успешна (близкое к оптимальному решение получено), иногда нет (тогда попытку можно повторить). Попытка состоит из двух шагов.

\begin{enumerate}
    \item Недетерминированный полиномиальный алгоритм генерирует некоторый вариант решения.
    \item Детерминированный алгоритм проверяет является ли решение правильным.
\end{enumerate}

В целом попытка представляет собой недетерминированный алгоритм полиномиальной сложности. Этим и объясняется название $NP$ класса. Хотя оба шага попытки и полиномиальны, но число попыток может оказаться экспоненциальным или факториальным (т.е. оценка количества попыток превышает $O(2^n)$).

К классу $NP$ относится задача о коммивояжере.
\begin{exampl}[Задача о коммивояжере]
    Задан набор городов и стоимость путешествия между любыми из них. Необходимо определить порядок, в котором следует посетить все города по одному разу и вернуться в исходный город, такой, чтобы общая стоимость путешествия оказалась минимальной.
\end{exampl}
\begin{proof}[Подход к решению]
    Всех возможных обходов $n$ городов, очевидно, $n!$. На данный момент не придумано детерминированного алгоритма, который занимался бы просмотром всех возможных путей. Уже для $20$ городов количество вариантов становится просто чудовищным. Читателю предлагается посчитайть самостоятельно, сколько времени потребуется его компьютеру, чтобы решить данную задачу(можно принять оптимистичное допущение, что за один такт он складывает два числа\ldots).
    
    Данная задача относится к классу $NP$, если мы определим полиномиальные алгоритмы для каждого из вышеизложенных шагов попытки.
    
    Как сгенерировать некоторый обход $n$ городов? Например так: записать названия городов в список городов; случайным образом выбрать город из списка городов, а затем удалить его оттуда, чтобы он не появился второй раз; повторить случайный выбор $n$ раз. Очевидно, что сложность генерации случайного обхода $O(n)$. Так как этот алгоритм недетерминирован, то каждый раз (с большой вероятностью) будет получаться новый порядок.
    
    Проверка стоимости также имеет сложность $O(n)$, так как для этого достаточно просуммировать $n$ стоимостей путешествия.
    
    Оба алгоритма полиномиальны, а поэтому задача о комивояжере принадлежит классу $NP$.
\end{proof}

Важно отметить что задачи класса $P$ также принадлежат и классу $NP$ ($P\subseteq NP$). Например, задача сортировки элементов массива принадлежат классу $P$ (сложность алгоритмов её решения находится между $O(n\log_2n)$ и $O(n^2)$). Но её можно решать также, как $NP$ задачу: генерировать случайную последовательность элементов массива ($O(n)$) и проверять, что она упорядочена ($O(n)$). А вот справедливо ли обратное ($P\supseteq NP$), то есть в нонечном итоге совпадают ли эти классы $P=NP$, до сих пор не доказано\footnote{По крайней мере еще никто не решил задачу коммивояжера полиномиальным детерминированным алгоритмом}.

Выделяют понятие \emph{$NP$-полная} задача. Задача называется $NP$-полной, если к ней можно свести все остальные задачи класса $NP$. Задача $A$ сводится (редуцируется) к задаче $B$, если алгоритм решения задачи $A$ можно преобразовать таким образом, чтобы он решал задачу $B$.

\begin{exampl}
    Гамильтоновым циклом в графе называется путь, проходящий через каждую вершину только один раз.
    
    Задача о поиске гамильтонова цикла сводится к задаче о коммивояжере следующим образом. Пусть $n$ --- количество вершин в графе. Каждая вершина графа --- это город. Стоимость пути вдоль каждого ребра графа полагается равной $1$. Стоимость пути между городами полагается равной $2$, если соответствующие вершины графа не соединены ребром.
    
    Теперь, если будет решена задача о коммивояжере, то будет найден кратчайший циклический путь, проходящий единожды по всем городам. Если стоимость найденного пути равна $n$ (то есть он состоит из ребер веса $1$), то этому пути соответствует гамильтонов цикл в графе. Если стоимость путешествия превышает $n$, то гамильтонова цикла в графе нет.
    \qed
\end{exampl}

Есла задача $A$ выполняется за полиномиальное время и сводима к $B$, то и задача $B$ решается за полиномиальное время. Практически применимых $NP$-полных задач очень много и, если хоть для одной из них будет найден полиномиальный детерминированный алгоритм, то все задачи будут им решены. До сих пор ни одна из таких попыток успехом не увенчалась. 

Далее перечислены формулировки некоторых $NP$-полных задач.
\begin{itemize}
    \item Раскраска графа. Вершины графа можно <<раскрасить>> в разные цвета так, чтобы концы каждого ребра были раскрашены разными цветами. Очевидно, что в графе с $n$ вершинами можно раскрасить вершины в $n$ разных цветов. В данной задаче требуется определить минимально необходимое количество цветов для такой раскраски.
    
    \item Раскладка по ящикам. Имеется набор объектов различных размеров $s_1,s_2,\ldots,s_n$. Имеется также некоторое количество ящиков фиксированного размера (самый большой объект в ящик входит). Необходимо определить наименьшее количество ящиков, необходимое для раскладки всех объектов.
    
    \item Упаковка рюкзака. Имеется $n$ объектов объемов $s_1,s_2,\ldots,s_n$ и стоимостей $c_1,c_2,\ldots,c_n$. Требуется упаковать рюкзак объемом $K$, так, чтобы его стоимость была максимальной.
    
    \item Сумма элементов подмножеств. Имеется $n$ объектов весами $s_1,s_2,\ldots,s_n$. Требуется найти такое подмножество объектов, чтобы сумма весов объектов, в него входящих, не превышала верхней границы $K$, но была наиболее близка к ней.
    
    \item Истинность КНФ выражения. КНФ --- последовательность булевых выражений, связанных операторами AND ($\land$), причем каждое выражение есть последовательность булевых переменных или их отрицаний, связанных операторами OR ($\lor$). Например:
    \[
        (a\lor b)\land(\overline{a}\lor c)\land(a\lor b\lor\overline{c}\lor\overline{d}).
    \]
    Существуют ли у переменных, входящих в выражение, такие значения истинности, подстановка которых делает все выражение истинным. Как число переменных $n$, так и сложность выражения не ограничены.
    
    \item Планирование работ. Имеется набор из $n$ работ. Известно время, необходимое для завершения каждой работы $t_1,t_2,\ldots,t_n$. Известны сроки $d_1,d_2,\ldots,d_n$, к которым работы должны быть завершены, а также штрафы $p_1,p_2,\ldots,p_n$, которые будут взысканы при срыве сроков. Необходимо установить последовательность выполнения работ, чтобы свести штрафы к минимуму.
\end{itemize}

В качестве упражнения читателю предлагается провести аналогии между приведенными обобщенными формулировками задач и практическими задачами. 

Следует также отметить, что кроме $NP$ выделют и другие классы сложности, например, $coNP$,$PS$, $ZPP$, $PP$, $RP$ и т.д. Узнать больше об этих классах можно в \cite{bib:hopkroft:automateIntro}.


\section{Вычислимое и невычислимое}

Формальное определение вычислимости довольно сложно и интуитивно. Далее изложены некоторые важные следствия так называемого тезиса Черча-Тьюринга, заключающегося в двух словах в том, что лишь некоторые функции из возможных могут быть вычислены. Два ученых практически одновременно получили результаты, занимаясь исследованиями в этой области в 1930-х годах. Можно сказать, что работа Тьюринга заложила фундамент современной вычислительной техники. Следует предупредить, что тезис Черча-Тьюринга является лишь тезисом, гипотезой --- его (пока?) невозможно ни доказать, ни опровергнуть. 

Как было указано выше, особенностью алгоритма явлеется его эффективность. То есть каждый шаг должен быть прост для выполнения. Прост --- значит, что его, например, может выполнить человек с помощью карандаша и бумаги за небольшое время.

Алан Тьюринг определил абстрактную машину, названную в честь создателя <<машиной Тьюринга>>, каждый шаг работы которой весьма прост. Машина Тьюринга считается эквивалентом понятия метода вычислений (или алгоритма). Также считается (пока мы верим в тезис Черча-Тьюринга), что машина Тьюринга способна делать все то, что доступно современному компьютеру. И если, например, доказано, что машина Тьюринга нечто вычислить не в силах, то и компьютеру это недоступно. 

\begin{figure}[!ht]
    \[
        \begin{array}{cccccccc}
            \cline{2-8}
            \multicolumn{1}{r}{L:}
                &\multicolumn{1}{|c|}{\diamondsuit}
                    &\multicolumn{1}{|c|}{a}
                        &\multicolumn{1}{|c|}{a}
                            &\multicolumn{1}{|c|}{b}
                                &\multicolumn{1}{|c|}{b}
                                    &\multicolumn{1}{|c|}{\diamondsuit}
                                        &\multicolumn{1}{|c}{\cdots}
                                            \\ 
            \cline{2-8}
            &&\Uparrow&&&&&\\
            &&S&&&&&
        \end{array}
    \]
    \caption{Машина Тьюринга}
    \label{fig:alg:turingMachine}
\end{figure}

Машину Тьюринга (см. рис. \ref{fig:alg:turingMachine}) составляют:
\begin{itemize}
    \item блок управления $S$;
    \item бесконечная в одну сторону (вправо) лента ячеек памяти $L$;
    \item головки чтения-записи значений ячеек $\Uparrow$.
\end{itemize}

Блок управления обладает множеством \emph{состояний}, одно из которых является \emph{текущим} и \emph{функцией переходов}. Одно из состояний является \emph{стартовым}: когда машина начинает работу, то это состояние является текущим. Одно или несколько состояний также являются \emph{завершающими} --- перейдя в это состояние, блок управления прекращает работу машины. 

Перед началом работы машины в ячейки ленты записываются символы из множества ленточных символов --- входные данные. Обычно первая (крайняя левая) ячейка ленты остается пустой, входные данные же записываются последовательно слева-направо, начиная со второй ячейки. Среди ленточных символов есть один особый символ $\diamondsuit$ --- \emph{пустой}. Этим символом заполняются все ячейки ленты, в которых нет входных данных. Головка чтения-записи устанавливается на начало входных данных, то есть на вторую ячейку ленты. Ячейка, на которую установлена головка, называется \emph{текущей}.

Шаг (\emph{переход}) машины Тьюринга выполняется так.
\begin{enumerate}
    \item Блок управления считывает с помощью головки текущий символ $l$ (значение текущей ячейки).
    \item В зависимости от текущего состояния $s$ и от текущего символа $l$ блок управления выполняет следующие действия:
    \begin{enumerate}
        \item изменяет текущее состояние новым состоянием $s'$;
        \item записывает в текущую ячейку новый символ $l'$;
        \item сдвигает головку чтения-записи по ленте либо вправо ($R$), либо влево ($L$) на одну ячейку.
    \end{enumerate}
    \item Если новое текущее состояние не является завершающим, то машина готова выполнить следующий переход. Иначе машина останавливается.
\end{enumerate}

Функция переходов $\delta$ однозначно задает выполнение перехода: 
\[\delta(s,l)=(s',l',m),\] 
где $m\in\{L,R\}$. Если значение функции переходов не определено для некоторой комбинации $(s,l)$, то машина останавливается. Остановка машины также произойдет при попытке передвинуть головку за левый край ленты.

Пусть задана машина Тьюринга с функцией переходов:
\begin{equation}
    \label{eq:alg:anbnMTpsi}
    \begin{array}{lll}
        \delta(1,a)=(2,x,R),        &\delta(1,y)=(4,y,R),   &\delta(2,a)=(2,a,R),\\
        \delta(2,y)=(2,y,R),        &\delta(2,b)=(3,y,L),   &\delta(3,y)=(3,y,L),\\
        \delta(3,a)=(3,a,L),        &\delta(3,x)=(1,x,R),   &\delta(4,y)=(4,y,R),\\
        \delta(4,\diamondsuit)=(F,\diamondsuit,L).&&
    \end{array}
\end{equation}

Читателю следует попробовать самостоятельно сделать вывод, при каком наборе символов на ленте машина остановится в состоянии $F$? При этом стартовым является состояние $1$. Выполните несколько проходов на произвольных цепочках $c\in\{a,b\}^+$.

Проследить работу машины Тьюринга удобно с помощью \emph{конфигураций}. Конфигурация представляется тройкой 
\[(c_1,s,c_2),\]
где $c_1$ --- цепочка из символов в ячейках ленты, слева от текущей (левая часть ленты); $c_2$ --- цепочка из символов в ячейках справа от текущей, включая текущий символ\footnote{Бесконечную последовательность пустых символов, завершающих правую часть ленты, опускают}; $s$ --- текущее состояние.

Допустим, что на ленте изначально записан набор символов $\diamondsuit aabb\diamondsuit$. Тогда начальная конфигурация:
\[(\diamondsuit,1,aabb\diamondsuit).\]

Далее выполняется переход $\delta(1,a)=(2,x,R)$ и получается конфигурация
\[(\diamondsuit x,2,abb\diamondsuit).\]

Затем будут выполнены следующие изменения конфигураций и переходы:
\[
    \begin{array}{llll}
        (\diamondsuit x,2,abb\diamondsuit)
            &\xrightarrow{\delta(2,a)=(2,a,R)}
                &(\diamondsuit xa,2,bb\diamondsuit)
                    &\xrightarrow{\delta(2,b)=(3,y,L)}\\
        (\diamondsuit x,3,ayb\diamondsuit)
            &\xrightarrow{\delta(3,a)=(3,a,L)}
                &(\diamondsuit,3,xayb\diamondsuit)
                    &\xrightarrow{\delta(3,x)=(1,x,R)}\\
        (\diamondsuit x,1,ayb\diamondsuit)
            &\xrightarrow{\delta(1,a)=(2,x,R)}
                &(\diamondsuit xx,2,yb\diamondsuit)
                    &\xrightarrow{\delta(2,y)=(2,y,R)}\\
        (\diamondsuit xxy,2,b\diamondsuit)
            &\xrightarrow{\delta(2,b)=(3,y,L)}
                &(\diamondsuit xx,3,yy\diamondsuit)
                    &\xrightarrow{\delta(3,y)=(3,y,L)}\\
        (\diamondsuit x,3,xyy\diamondsuit)
            &\xrightarrow{\delta(3,x)=(1,x,R)}
                &(\diamondsuit xx,1,yy\diamondsuit)
                    &\xrightarrow{\delta(1,y)=(4,y,R)}\\
        (\diamondsuit xxy,4,y\diamondsuit)
            &\xrightarrow{\delta(4,y)=(4,y,R)}
                &(\diamondsuit xxyy,1,\diamondsuit)
                    &\xrightarrow{\delta(4,\diamondsuit)=(F,\diamondsuit,L)}\\
        (\diamondsuit xxy,F,y\diamondsuit)
            &\xrightarrow{\text{останов}}
                &
                    &
    \end{array}
\]

Углубившись в анализ работы приведенной выше машины, читатель поймет, что она отмечает первый символ $a$ символом $x$ и перемещает головку вправо, на символ $b$, пропуская символы $a$ и $y$. Затем она отмечает символ $b$ символом $y$ и перемещает головку влево, на символ $x$, пропуская символы $y$ и $a$. Дойдя до крайнего справа символа $x$, машина сдвигает головку на символ вправо и повторяет процесс сначала. Если при этом машина обнаруживает, что символа $a$ после символа  $x$ нет, то она удостоверяется, что все символы $b$ отмечены символом $y$, для чего пропускает все символы $y$ до тех пор, пока ей не встретится $\diamondsuit$.

Для того, чтобы решить некоторую задачу машиной Тьюринга, приходится учитывать её весьма немногочисленные, но мощные возможности. На первый взгляд тут отсутствуют привычные программисту средства: последовательность,  условие и итерация. Машина Тьюринга может изменить состояние, записать вместо текущего новый символ (это называется <<отметить>>) и сдвинуть головку. Каждое состояние машины определяет маленькую подзадачу, которую она в данный момент решает. Например, найти слева или справа определенный символ, заменить символ на заданный, и т.д.

Чтобы разобраться в заданной функции переходов иногда удобно представить её в виде графа. Вершинами графа будут внутренние состояния блока управления, дуги --- переходами. При этом дуга $(s,s')$, соответствующая переходу
\[\delta(s,l)=(s',l',m),\] 
будет помечена так: $l|l'm$. Приведенная выше машина Тьюринга в виде графа представлена на рисунке \ref{fig:alg:anbnMTGraph}.
\begin{figure}
    \[
        {\xymatrix{
            *{}
                &2 \ar[dr]^{b|yL} \ar@(ul,ur)[]^{a|aR,y|yR}
                    &*{}
                        \\
            *++[o][F=]{1} \ar[ur]^{a|xR} \ar[dr]_{y|yR}
                &*{}
                    &3 \ar[ll]_{x|xR} \ar@(ur,dr)[]^{y|yL,a|aL}
                        \\
            *{}
                &4 \ar[r]^{\diamondsuit|\diamondsuit L} \ar@(dl,dr)[]_{y|yR}
                    &*++[o][F=]{F}
        }}
    \]
    \caption{Граф машины Тьюринга (см. формулу \ref{eq:alg:anbnMTpsi})}
    \label{fig:alg:anbnMTGraph}
\end{figure}
На данном графе можно видеть следующие аналоги элементам структурного программирования.
\begin{enumerate}
    \item Последовательности. Например, путь $(4,F)$.
    \item Условие. Например, из состояния $1$ возможен переход в вершину $2$, если текущий символ --- $a$, или в вершину $4$, если текущий символ --- $y$.
    \item Итерация. Например, цикл на графе $1,2,3$. Кроме того, например, вершина $2$ также представляет собой цикл, пропускающий на ленте символы $a$ и $y$.
\end{enumerate}

\begin{exampl}
    Задача. Удвоить целое число $X$, записанное на ленте в унитарном виде\footnote{Унитарная форма записи натурального числа $n$ представляет собой строку из $n$ единиц: $\underbrace{11\cdots 11}_n$}.
\end{exampl}
\begin{proof}[Решение]
    Число $X$ в унитарном виде записывается на ленту. Унитарное представление результата $Y=2X$ будет получено справа от $X$, после символа $\diamondsuit$. По завершении работы в состоянии $F$ головка машины будет установлена на начало $Y$.
    
    Основная идея: каждая $1$-ца в представлении $X$ отмечается символом $v$; для каждой неотмеченной единицы из $X$, к концу представления $Y$ добавляются две единицы.
    
    Работа начинается из состояния $1$ (<<неотмеченная единица>>). Если текущий символ $1$, то он отмечается символом $v$, головка сдвигается вправо и выполняется переход к состоянию $2$ --- <<пропуск неотмеченных единиц в представлении X>>: $\delta(1,1)=(2,x,R)$. В состоянии $2$ машина пропускает единицы: $\delta(2,1)=(2,1,R)$. Если в состоянии $2$, головка считывает разделитель $\diamondsuit$, то выполняется переход к состоянию $3$ (<<переход в конец представления Y>>): $\delta(2,\diamondsuit)=(3,\diamondsuit,R)$. В состоянии $2$ машина пропускает единицы представления $Y$: $\delta(3,1)=(3,1,R)$. Если в состоянии $3$, головка считывает разделитель $\diamondsuit$, то машина переходит в состояние $4$ (<<первая единица добавлена в конец $Y$>>): $\delta(3,\diamondsuit)=(4,1,R)$. Из состояния $4$ машина переходит в состояние $5$ (<<вторая единица добавлена в конец $Y$>>):$\delta(4,\diamondsuit)=(5,1,L)$. Далее необходимо сдвинуться влево, до крайнего справа символа $v$. Машина пропускает возможные символы слева, кроме $v$: $\delta(5,1)=(5,1,L)$, $\delta(5,\diamondsuit)=(5,\diamondsuit,L)$. Дойдя до заветного $v$, машина смещает головку вправо и переходит в состояние $1$: $\delta(5,v)=(1,v,R)$. Процесс повторяется. Впрочем, возможно, что единицы в представлении $X$ закончились: $\delta(1,\diamondsuit)=(F,\diamondsuit,R)$.
    
    Полученная функция переходов
    \[
        \begin{split}
            \delta=\{
                (1,1)           \mapsto(2,x,R),
                (2,1)           \mapsto(2,1,R),
                (2,\diamondsuit)\mapsto(3,\diamondsuit,R),\\
                (3,1)           \mapsto(3,1,R),
                (3,\diamondsuit)\mapsto(4,1,R),
                (4,\diamondsuit)\mapsto(5,1,L),\\
                (5,1)           \mapsto(5,1,L),
                (5,\diamondsuit)\mapsto(5,\diamondsuit,L),
                (5,v)           \mapsto(1,v,R),\\
                (1,\diamondsuit)\mapsto(F,\diamondsuit,R)
            \}
        \end{split}
    \]
    полностью определяет работу необходимой машины Тьюринга.
\end{proof}

\begin{exampl}
    Задача. Увеличить на $1$ целое число $X$, записанное на ленте в двоичной системе счисления.
\end{exampl}
\begin{proof}[Решение]
    Число $X$ в двоичном виде (старший разряд слева) записывается на ленту. Результат $Y=X+1$ будет получен на месте $X$. По завершении работы в состоянии $F$ головка машины будет установлена на начало $Y$.
    
    Основная идея: сдвинуться в конец представления числа, двигаться влево, распространяя <<единицу переноса>>. Если возникнет перенос из самого старшего разряда, необходимо сдвинуть число на разряд вправо и дописать $1$ в старшем разряде.

    Проход до младшего разряда:
    \[
        \begin{array}{lll}
            \delta(1,1)=(1,1,R),
                &\delta(1,0)=(1,0,R),
                    &\delta(1,\diamondsuit)=(2,\diamondsuit,L).
        \end{array}
    \]            

    Распространение единицы переноса:
    \[
        \begin{array}{lll}
            \delta(2,1)=(2,0,L),
                &\delta(2,0)=(3,1,L).
                    &
        \end{array}
    \]            
        
    Установка головки на старший разряд разультата:
    \[
        \begin{array}{lll}
            \delta(3,0)=(3,0,L),
                &\delta(3,1)=(3,1,L),
                    &\delta(3,\diamondsuit)=(F,\diamondsuit,R).
        \end{array}
    \]            

    Перенос из старшего разряда. Требуется сдвиг всего числа на один разряд вправо и установка головки на старший разряд результата.
    \[
        \begin{array}{lll}
            \delta(2,\diamondsuit)=(4,\diamondsuit,R),
                &\delta(4,1)=(4,1,R),
                    &\delta(4,0)=(5,1,R),\\
            \delta(5,1)=(4,0,R),
                &\delta(5,0)=(5,0,R),
                    &\delta(4,\diamondsuit)=(3,1,L),\\
            \delta(5,\diamondsuit)=(3,0,L).
                &
                    &
        \end{array}
    \]

    Читателю предлагается самому разобраться в переходах, а лучше определить их самостоятельно и сверить результаты\footnote{В частности в сети Интернет можно найти множество программ, реализующих машину Тьюринга. Например, онлайн версия \url{http://matinf.igpu.ru/simulator/tm.html}. Проверьте себя и авторов}.
\end{proof}

Произвольную машину Тьюринга можно закодировать --- то есть представить в виде последовательности символов. \emph{Универсальной} называется машина Тьюринга, на которой можно осуществить переходы любой другой машины Тьюринга. Код произвольной машины Тьюринга $M$, записывается на ленту универсальной машины, которая и моделирует работу машины $M$. В работе Тьюринга показано, как задается универсальная машина и как закодировать произвольную машину. См. детали, например, в \cite{bib:mcconnel:alghorithmAnalysis}. Весьма похоже на то, как выполняется программа на компьютере, не так ли\footnote{В настоящее время хостерами активно используются так называемые виртуальные машины --- программы-эмуляторы, моделирующие работу аппаратной части компьютера. Управлять виртуальным компьютером несколько проще, например, его можно один раз настроить (установить операционную систему, приложения, сервисы и т.д.), а затем просто копировать при необходимости. Очевидно, что настоящий <<железный>> компьютер, который будет выполнять такой эмулятор должен быть достаточно мощным}?

Не все чётко сформулированные задачи можно решить \emph{алгоритмически}. То есть решить за \emph{конечное} время. Невозможно будет создать и машину Тьюринга, решающую эту задачу. Одна из таких задач --- проблема определения останова метода вычислений для некоторого ввода (входных данных). Допустим, что такой алгоритм существует: $H(A,D)$, где $A$ --- некоторый метод (выраженный программой, $D$ --- ввод для метода $A$. $H(A,D)$ возвращает истину, если $A(D)$ остановится и ложь, если $A(D)$ выполняется вечно. Рассмотрим псевдокод \ref{alg:alg:stopParadox} метода вычислений. Допустим, мы выполнили вызов $P(0)$. Остановится ли данный метод? Если $H(P,0)$ вернет истину (то есть $P(0)$ останавливается), то $P(0)$ будет выполняться вечно. Иначе, если $H(P,0)$ вернет ложь (то есть $P(0)$ выполняется вечно), то $P(0)$ тут же остановится. Данное противоречие говорит о том, что \emph{алгоритм} $H(A,D)$ существовать не может.
\begin{algorithm}
    \caption{$P(D)$. Неразрешимость проблемы останова}
    \label{alg:alg:stopParadox}
    \begin{algorithmic}[1]
        \REQUIRE{$D$ --- некоторые входные данные(не столь важно какие)}
        
        \IF{$H(P,D)=\TRUE$}
            \WHILE{\TRUE}
                \STATE{}
                \COMMENT{Бесконечный цикл}
            \ENDWHILE
        \ENDIF
    \end{algorithmic}
\end{algorithm}
Данное утверждение строго доказывается для машины Тьюринга, но общий подход указанный парадокс хорошо  иллюстрирует. Приняв тезис Черча-Тьюринга, придется мириться с тем, что не все задачи можно решить с помощью алгоритма\footnote{Тем приятнее, когда это всё же получается\ldots}.


\section*{Задания}
\addcontentsline{toc}{section}{Задания}

\begin{enumerate}
    \item Имеет ли смысл анализ времени выполнения метода вычислений?
    
    \item Расположите функции в порядке возрастания скорости роста. Если некоторые растут одинаково быстро --- объедините их в группу.
    \[
        \begin{array}{lllll}
            2^n;        &\log_2\log_2n; &n^3+\log_2n;   &\log_2n;   &n-2n^2+6n^3;\\
            2^{n-1};    &n^2;           &n^3;           &n\log_2n;  &(\log_2n)^2;\\
            \sqrt{n};   &6;             &n!;            &n;         &\left(\frac{3}{2}\right)^n
        \end{array}
    \]
    
    \item Для каждой из приведенных ниже функций $f$ и $g$ выполняется одно из равенств: либо $f=O(g)$, либо $g=O(f)$, но не оба сразу. Определите, какой случай имеет место.
    \[
        \begin{array}{|l|l|}
                                                                                        \hline
            f(n)=(n^2-n)/2,g(n)=5n          &f(n)=n\log_2n,g(n)=\frac{n}{2}\sqrt{n} \\  \hline
            f(n)=n+3\sqrt{n},g(n)=n^2       &f(n)=n+\log_2n,g(n)=\sqrt{n}           \\  \hline
            f(n)=n+n\log_2n,g(n)=n\sqrt{n}  &f(n)=\log_2\log_2n,g(n)=\log_2\sqrt{n} \\  \hline
            f(n)=n^2+2n+4,g(n)=n^3          &f(n)=(\log_2n)^2,g(n)=5\sqrt{n}        \\  \hline
        \end{array}
    \]
    
    \item Подсчитать (в ряде случаев приближенно) сколько раз будет выполнена ключевая операция $S$. Какому классу сложности $O(f)$ принадлежит оценка времени выполнения алгоритма $A$:
    \begin{enumerate}
        \item $A$:
            \begin{algorithmic}[1]
                \STATE{$i=1$} %FIXME,TODO!!!
                \WHILE{$i\leq n$}
                    \STATE{$S$}
                    \STATE{$i\gets 2\cdot i$}
                \ENDWHILE
            \end{algorithmic}
        \item $A$:
            \begin{algorithmic}[1]
                \STATE{$i=1$}
                \WHILE{$i\leq n$}
                    \STATE{$i\gets 2\cdot i$}
                    \WHILE{$j\leq i$}
                        \STATE{$S$}
                        \STATE{$j\gets j+1$}
                    \ENDWHILE
                \ENDWHILE
            \end{algorithmic}
        \item $A$:
            \begin{algorithmic}[1]
                \STATE{$i=1$}
                \WHILE{$i\leq n$}
                    \STATE{$j\gets 1$}
                    \WHILE{$j\leq n$}
                        \STATE{$S$}
                        \STATE{$j\gets j+1$}
                    \ENDWHILE
                    \STATE{$i\gets i+1$}
                \ENDWHILE
            \end{algorithmic}
        \item $A$:
            \begin{algorithmic}[1]
                \STATE{$i=1$}
                \WHILE{$i\leq n$}
                    \STATE{$j=1$}
                    \WHILE{$j\leq n$}
                        \STATE{$S$}
                        \STATE{$j\gets 2\cdot j$}
                    \ENDWHILE
                    \STATE{$i\gets i+1$}
                \ENDWHILE
            \end{algorithmic}
        \item $A$:
            \begin{algorithmic}[1]
                \STATE{$i=1$}
                \WHILE{$i\leq n$}
                    \STATE{$j=1$}
                    \WHILE{$j\leq i$}
                        \STATE{$S$}
                        \STATE{$j\gets j+1$}
                    \ENDWHILE
                    \STATE{$i\gets i+1$}
                \ENDWHILE
            \end{algorithmic}
        \item $A$:
            \begin{algorithmic}[1]
                \STATE{$i=1$}
                \WHILE{$i\leq n$}
                    \STATE{$j=1$}
                    \WHILE{$j\leq i$}
                        \STATE{$k=1$}
                        \WHILE{$k\leq i$}
                            \STATE{$S$}
                            \STATE{$k\gets k+1$}
                        \ENDWHILE
                        \STATE{$j\gets j+1$}
                    \ENDWHILE
                    \STATE{$i\gets i+1$}
                \ENDWHILE
            \end{algorithmic}
        \item $A$:
            \begin{algorithmic}[1]
                \STATE{$i=1$}
                \WHILE{$i\leq n$}
                    \STATE{$i\gets 5\cdot i$}
                    \WHILE{$j\leq i$}
                        \STATE{$S$}
                        \STATE{$j\gets j+2$}
                    \ENDWHILE
                \ENDWHILE
            \end{algorithmic}
        \item $A$:
            \begin{algorithmic}[1]
                \FOR{i=1 to n}
                    \STATE{$a[i]\gets 0$}
                \ENDFOR
                
                \REPEAT
                    \STATE{$j\gets 1$}
                    \STATE{$c\gets 1$}
                
                    \WHILE{$j\leq n$ \AND $c=1$}
                        \STATE{$S$}
                        \STATE{$a[j]\gets a[j]+1$}
                        \IF{$a[j]>7$}
                            \STATE{$a[j]\gets 0$}
                            \STATE{$c\gets 1$}
                            \STATE{$j\gets j+1$}
                        \ELSE
                            \STATE{$c\gets 0$}                        
                        \ENDIF
                    \ENDWHILE
                \UNTIL{j>n}
            \end{algorithmic}
    \end{enumerate}

    \item Какое значение выводит каждый блок кода $B$?
    \begin{enumerate}
        \item $B$:
            \begin{algorithmic}[1]
                \STATE{$c=0$}
                \FOR{$i=0$ to $n$}
                    \STATE{$c\gets c+1$}
                \ENDFOR
                \PRINT{$c$}
            \end{algorithmic}
        \item $B$:
            \begin{algorithmic}[1]
                \STATE{$c=0$}
                \FOR{$i=0$ to $n$}
                    \FOR{$j=0$ to $n$}
                        \STATE{$c\gets c+1$}
                    \ENDFOR
                \ENDFOR
                \PRINT{$c$}
            \end{algorithmic}
        \item $B$:
            \begin{algorithmic}[1]
                \STATE{$c=0$}
                \FOR{$i=0$ to $n$}
                    \FOR{$j=i$ to $n$}
                        \FOR{$k=j$ to $n$}
                            \STATE{$c\gets c+1$}
                        \ENDFOR
                    \ENDFOR
                \ENDFOR
                \PRINT{$c$}
            \end{algorithmic}
    \end{enumerate}
    
    \item Дать оценку времени выполнения алгоритма вычисления среднего значения элементов массива длины $n$.
    
    \item Дать оценку времени выполнения алгоритма вычисления наибольшего значения среди элементов массива длины $n$.
    
    \item Дать оценку времени выполнения алгоритма перемножения двух квадратных матриц размером $n\times n$.
    
    \item Проанализировать алгоритм пузырьковой сортировки (см. псевдокод \ref{alg:alg:bubbleSort}).
    \begin{algorithm}
        \caption{$bubbleSort(a,n)$ --- сортировка пузырьком}
        \label{alg:alg:bubbleSort}
        \begin{algorithmic}[1]
            \REQUIRE{$a$ --- массив элементов линейно упорядоченного множества. Длина массива $n$, обращение к элементу по $i$-му индексу: $a[i]$. Первый элемент массива $a[0]$, последний $a[n-1]$. Операция $swap$ меняет местами значения двух её аргументов.}
            \ENSURE{Отсортированный в порядке возрастания массив $a$}
            
            \FOR{$i=2$ to $n$}
                \STATE{$l=n-i$}
                \FOR{$j=0$ to $l$}
                    \IF{$a[j]>a[j+1]$}
                        \STATE{$swap(a[j],a[j+1])$}
                    \ENDIF
                \ENDFOR
            \ENDFOR
        \end{algorithmic}
    \end{algorithm}
    
    \item Проанализировать алгоритм сортировки выбором (см. псевдокод \ref{alg:alg:selectSort}):
    \begin{algorithm}
        \caption{$selectSort(a,n)$ --- сортировка выбором}
        \label{alg:alg:selectSort}
        \begin{algorithmic}[1]
            \REQUIRE{$a$ --- массив элементов линейно упорядоченного множества. Длина массива $n$, обращение к элементу по $i$-му индексу: $a[i]$. Первый элемент массива $a[0]$, последний $a[n-1]$. Операция $swap$ меняет местами значения двух её аргументов.}
            \ENSURE{Отсортированный в порядке возрастания массив $a$}
            
            \FOR{$i=0$ to $n-2$}
                \STATE{$min=a[i]$}
                \STATE{$k_{min}=i$}
                \FOR{$j=i+1$ to $n-1$}
                    \IF{$a[j]<min$}
                        \STATE{$min=a[j]$}
                        \STATE{$k_{min}=j$}
                    \ENDIF
                \ENDFOR
                \STATE{$swap(a[i],a[k_{min}])$}
            \ENDFOR
        \end{algorithmic}
    \end{algorithm}
    
    \item Проанилизировать в качестве примера наихудшее время выполнения алгоритма бинарного поиска в упорядоченном массиве (см. псевдокод \ref{alg:rec:binSearchIter}).
    
    \item Реализовать итеративный и рекурсивный алгоритмы поиска $n$-го числа Фибоначчи. Построить сравнительную таблицу времени выполнения программы для поиска $n$-го числа. Выдвинуть предположения о классах роста.
    
    \item Определите алгоритмы генерации и проверки решения для $NP$-полных задач.
    \begin{enumerate}
        \item раскраска графа;
        \item раскладка по ящикам;
        \item упаковка рюкзака;
        \item сумма элементов подмножеств;
        \item истинность КНФ выражения;
        \item планирование работ.
    \end{enumerate}
    
    \item Что делают перечисленные ниже машины Тьюринга? Начальное состояние --- $1$, а допускающее --- $F$:
    \begin{enumerate}
        \item 
            \(
                \begin{array}{lll}
                    \delta(1,a)=(1,b,R),&\delta(1,b)=(1,a,R),&\delta(1,\diamondsuit)=(F,\diamondsuit,L);
                \end{array}
            \)
        \item 
            \(
                \begin{array}{lll}
                    \delta(1,a)=(2,a,R),&\delta(1,\diamondsuit)=(F,\diamondsuit,L),&\delta(2,b)=(1,b,R);
                \end{array}
            \)
        \item 
            \(
                \begin{array}{lll}
                    \delta(1,1)=(1,x,R),
                        &\delta(1,\diamondsuit)=(2,\diamondsuit,L),
                            &\delta(2,x)=(3,1,R),\\
                    \delta(3,1)=(3,1,R),
                        &\delta(3,\diamondsuit)=(2,1,L),
                            &\delta(2,1)=(2,1,L),\\
                    \delta(2,\diamondsuit)=(F,\diamondsuit,R);
                        &
                            &
                \end{array}
            \)
        \item 
            \(
                \begin{array}{lll}
                    \delta(1,1)=(2,1,R),
                        &\delta(2,2)=(2,2,R),
                            &\delta(2,\diamondsuit)=(F,\diamondsuit,L),\\
                    \delta(1,0)=(3,0,R),
                        &\delta(3,0)=(3,0,R),
                            &\delta(3,1)=(4,1,R),\\
                    \delta(4,\diamondsuit)=(F,\diamondsuit,R);
                        &
                            &
                \end{array}
            \)
    \end{enumerate}
    
    \item Спроектировать машины Тьюринга, определяющие принадлежность цепочки входных символов множеству:
    \begin{enumerate}
        \item $\{w|w\in{a,b}^*, |w| \text{--- нечётно}\}$; 
        \item $\{a^nb^m|n\geq m\geq 1\}$;
        \item $\{w|w\in{a,b}^*, \#_a(w)=\#_b(w)\}$;
        \item $\{wcw|w\in{a,b}^*\}$;
        \item $\{ww|w\in{a,b}^+\}$.
    \end{enumerate}
    
    \item Определить машину Тьюринга для:
    \begin{enumerate}
        \item сложения, 
        \item вычитания, 
        \item умножения
    \end{enumerate}
    двух целых чисел, записанных на ленте в унитарном виде и разделенных символом $\diamondsuit$.
    
    \item Определить машину Тьюринга для нахождения:
    \begin{enumerate}
        \item декремента целого числа;
        \item результата сложения двух целых чисел;
        \item результата вычитания двух целых чисел.
    \end{enumerate}
    числа представляются в двоичной (троичной) системе счисления и разделяются при необходимости символом $\diamondsuit$.

    \item Определить машину Тьюринга для:
    \begin{enumerate}
        \item нахождения зеркального отражения строки символов $s$: $s\in\{1,0\}^+$;
        \item нахождения зеркального отражения строки символов $s$:$s\in\{a,b,c\}^+$;
        \item проверки строки $s$ на принадлежность множеству палиндромов\footnote{<<а роза упала на лапу азора>>, <<аргентина манит негра>>}:$s\in\{a,b,c\}^+$.
    \end{enumerate}
    
    
    \item Определить машину Тьюринга для вычисления функций:
    \begin{enumerate}
        \item $f(x)=x+2$;
        \item $f(x)=2x$;
        \item $f(x)=x\pmod 3$.
    \end{enumerate}
    аргументы функций --- целые числа, представленные в унитарном виде.
    
\end{enumerate}
